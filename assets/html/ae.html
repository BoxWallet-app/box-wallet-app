<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
</head>
<body>
<p id="show_info">-</p>
<script type="text/javascript" src="../js/aepp-sdk.browser-script-770.js"></script>
<script type="text/javascript">

  const sourceCodeTokenBasic = `
// ISC License
//
// Copyright (c) 2017, aeternity developers
//
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
// REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
// INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
// LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
// OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
// PERFORMANCE OF THIS SOFTWARE.


// THIS IS NOT SECURITY AUDITED
// DO NEVER USE THIS WITHOUT SECURITY AUDIT FIRST

@compiler >= 4

include "Option.aes"

/// @title - Fungible token basic
contract FungibleToken =

  // This defines the state of type record encapsulating the contract's mutable state
  record state =
    { owner        : address      // the smart contract's owner address
    , total_supply : int          // total token supply
    , balances     : balances     // balances for each account
    , meta_info    : meta_info }  // token meta info (name, symbol, decimals)

  // This is the meta-information record type
  record meta_info =
    { name     : string
    , symbol   : string
    , decimals : int }

  // This is a type alias for the balances map
  type balances = map(address, int)

  // Declaration and structure of datatype event
  // and events that will be emitted on changes
  datatype event = Transfer(address, address, int)

  // List of implemented extensions for the deployed contract
  entrypoint aex9_extensions() : list(string) = []

  entrypoint init(name: string, decimals : int, symbol : string, initial_owner_balance : option(int)) =
    require(String.length(name) >= 1, "STRING_TOO_SHORT_NAME")
    require(String.length(symbol) >= 1, "STRING_TOO_SHORT_SYMBOL")
    require_non_negative_value(decimals)
    // If negative initial owner balance is passed, abort the execution
    let initial_supply = Option.default(0, initial_owner_balance)
    require_non_negative_value(initial_supply)

    let owner = Call.caller
    { owner        = owner,
      total_supply = initial_supply,
      balances     = Option.match({}, (balance) => { [owner] = balance }, initial_owner_balance),
      meta_info    = { name = name, symbol = symbol, decimals = decimals } }

  // Get the token meta info
  entrypoint meta_info() : meta_info =
    state.meta_info

  // Get the token total supply
  entrypoint total_supply() : int =
    state.total_supply

  // Get the token owner address
  entrypoint owner() : address =
    state.owner

  // Get the balances state
  entrypoint balances() : balances =
    state.balances


  entrypoint balance(account: address) : option(int) =
    Map.lookup(account, state.balances)

  stateful entrypoint transfer(to_account: address, value: int) =
    internal_transfer(Call.caller, to_account, value)

  // INTERNAL FUNCTIONS

  function require_owner() =
    require(Call.caller == state.owner, "ONLY_OWNER_CALL_ALLOWED")

  function require_non_negative_value(value : int) =
    require(value >= 0, "NON_NEGATIVE_VALUE_REQUIRED")

  function require_balance(account : address, value : int) =
    switch(balance(account))
      Some(balance) =>
        require(balance >= value, "ACCOUNT_INSUFFICIENT_BALANCE")
      None => abort("BALANCE_ACCOUNT_NOT_EXISTENT")

  stateful function internal_transfer(from_account: address, to_account: address, value: int) =
    require_non_negative_value(value)
    require_balance(from_account, value)
    put(state{ balances[from_account] @ b = b - value })
    put(state{ balances[to_account = 0] @ b = b + value })
    Chain.event(Transfer(from_account, to_account, value))

		`


   const sourceCodeToken = `
// ISC License
//
// Copyright (c) 2017, aeternity developers
//
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
// REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
// INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
// LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
// OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
// PERFORMANCE OF THIS SOFTWARE.


// THIS IS NOT SECURITY AUDITED
// DO NEVER USE THIS WITHOUT SECURITY AUDIT FIRST

@compiler >= 4

include "Option.aes"

/// @title - Fungible token with all the extensions - burn, mint, allowances
contract FungibleTokenFull =

  // This defines the state of type record encapsulating the contract's mutable state
  record state =
    { owner        : address      // the smart contract's owner address
    , total_supply : int          // total token supply
    , balances     : balances     // balances for each account
    , meta_info    : meta_info    // token meta info (name, symbol, decimals)
    , allowances   : allowances   // owner of account approves the transfer of an amount to another account
    , swapped      : map(address, int) }

  // This is the meta-information record type
  record meta_info =
    { name     : string
    , symbol   : string
    , decimals : int }

  // This is the format of allowance record type that will be used in the state
  record allowance_accounts = { from_account : address, for_account : address }

  // This is a type alias for the balances map
  type balances = map(address, int)

  // This is a type alias for the allowances map
  type allowances = map(allowance_accounts, int)

  // Declaration and structure of datatype event
  // and events that will be emitted on changes
  datatype event =
    Transfer(address, address, int)
    | Allowance(address, address, int)
    | Burn(address, int)
    | Mint(address, int)
    | Swap(address, int)

  // List of supported extensions
  entrypoint aex9_extensions() : list(string) = ["allowances", "mintable", "burnable", "swappable"]

  // Create a fungible token with
  // the following \`name\` \`symbol\` and \`decimals\`
  // and set the inital smart contract state
  entrypoint init(name: string, decimals : int, symbol : string, initial_owner_balance : option(int)) =
    // If the \`name\` lenght is less than 1 symbol abort the execution
    require(String.length(name) >= 1, "STRING_TOO_SHORT_NAME")
    // If the \`symbol\` length is less than 1 symbol abort the execution
    require(String.length(symbol) >= 1, "STRING_TOO_SHORT_SYMBOL")
    // If the provided value for \`decimals\` is negative abort the execution
    require_non_negative_value(decimals)
    // If negative initial owner balance is passed, abort the execution
    let initial_supply = Option.default(0, initial_owner_balance)
    require_non_negative_value(initial_supply)

    let owner = Call.caller
    { owner        = owner,
      total_supply = initial_supply,
      balances     = Option.match({}, (balance) => { [owner] = balance }, initial_owner_balance),
      meta_info    = { name = name, symbol = symbol, decimals = decimals },
      allowances   = {},
      swapped      = {} }

  // Get the token meta info
  entrypoint meta_info() : meta_info =
    state.meta_info

  // Get the token total supply
  entrypoint total_supply() : int =
    state.total_supply

  // Get the token owner address
  entrypoint owner() : address =
    state.owner

  // Get the balances state
  entrypoint balances() : balances =
    state.balances

  // Get balance for address of \`owner\`
  // returns option(int)
  // If the \`owner\` address haven't had any token balance
  // in this smart contract the return value is None
  // Otherwise Some(int) is returned with the current balance
  entrypoint balance(account: address) : option(int) =
    Map.lookup(account, state.balances)

  // Get all swapped tokens stored in state
  entrypoint swapped() : map(address, int) =
    state.swapped

  // Get the allowances state
  entrypoint allowances() : allowances =
    state.allowances

  // Get the allowance for passed \`allowance_accounts\` record
  // returns option(int)
  // This will lookup and return the allowed spendable amount
  // from one address for another
  // If there is no such allowance present result is None
  // Otherwise Some(int) is returned with the allowance amount
  entrypoint allowance(allowance_accounts : allowance_accounts) : option(int) =
    Map.lookup(allowance_accounts, state.allowances)

  // Get the allowance for caller from \`from_account\` address
  // returns option(int)
  // This will look up the allowances and return the allowed spendable amount
  // from \`from_account\` for the transaction sender \`Call.caller\`
  // If there is no such allowance present result is None
  // Otherwise Some(int) is returned with the allowance amount
  entrypoint allowance_for_caller(from_account: address) : option(int) =
    allowance({ from_account = from_account, for_account = Call.caller })

  // Send \`value\` amount of tokens from address \`from_account\` to address \`to_account\`
  // The transfer_allowance method is used for a withdraw workflow, allowing contracts to send
  // tokens on your behalf, for example to "deposit" to a contract address and/or to charge
  // fees in sub-token contract.
  // The execution will abort and fail if there is no allowance set up previous this call
  stateful entrypoint transfer_allowance(from_account: address, to_account: address, value: int) =
    let allowance_accounts = { from_account = from_account, for_account = Call.caller }
    internal_transfer(from_account, to_account, value)
    internal_change_allowance(allowance_accounts, -value)

  // Create allowance for \`for_account\` to withdraw from your account \`Call.caller\`,
  // multiple times, up to the \`value\` amount.
  // This function will abort and fail if called again when there is allowance
  // already set for these particular accounts pair.
  stateful entrypoint create_allowance(for_account: address, value: int) =
    // Check if the passed value is not negative
    require_non_negative_value(value)
    // Set the allowance account pair in the memory variable
    let allowance_accounts = { from_account =  Call.caller, for_account = for_account }
    // Check if there is no allowance already present in the state
    // for these particular accounts pair.
    require_allowance_not_existent(allowance_accounts)
    // Save the allowance value for these accounts pair in the state
    put(state{ allowances[allowance_accounts] = value })
    // Fire Allowance event to include it in the transaction event log
    Chain.event(Allowance(Call.caller, for_account, value))

  // Allows to change the allowed spendable value for \`for_account\` with \`value_change\`
  stateful entrypoint change_allowance(for_account: address, value_change: int) =
    let allowance_accounts = { from_account =  Call.caller, for_account = for_account }
    internal_change_allowance(allowance_accounts, value_change)

  // Resets the allowance given \`for_account\` to zero.
  stateful entrypoint reset_allowance(for_account: address) =
    let allowance_accounts = { from_account = Call.caller, for_account = for_account }
    internal_change_allowance(allowance_accounts, - state.allowances[allowance_accounts])

  /// Transfer the balance of \`value\` from \`Call.caller\` to \`to_account\` account
  stateful entrypoint transfer(to_account: address, value: int) =
    internal_transfer(Call.caller, to_account, value)

  // Destroys \`value\` tokens from \`Call.caller\`, reducing the total supply.
  // \`Burn\` event with \`Call.caller\` address and \`value\`.
  stateful entrypoint burn(value: int) =
    require_balance(Call.caller, value)
    require_non_negative_value(value)
    put(state{ total_supply = state.total_supply - value, balances[Call.caller] @ b = b - value })
    Chain.event(Burn(Call.caller, value))

  // Creates \`value\` tokens and assigns them to \`account\`, increasing the total supply.
  // Emits a \`Mint\` event with \`account\` and \`value\`.
  stateful entrypoint mint(account: address, value: int) =
    require_owner()
    require_non_negative_value(value)
    put(state{ total_supply = state.total_supply + value, balances[account = 0] @ b = b + value })
    Chain.event(Mint(account, value))

  stateful entrypoint swap() =
    let balance = Map.lookup_default(Call.caller, state.balances, 0)
    burn(balance)
    put(state{ swapped[Call.caller] = balance })
    Chain.event(Swap(Call.caller, balance))

  stateful entrypoint check_swap(account: address) : int =
    Map.lookup_default(account, state.swapped, 0)

  // INTERNAL FUNCTIONS

  function require_owner() =
    require(Call.caller == state.owner, "ONLY_OWNER_CALL_ALLOWED")

  function require_non_negative_value(value : int) =
    require(value >= 0, "NON_NEGATIVE_VALUE_REQUIRED")

  function require_balance(account : address, value : int) =
    switch(balance(account))
      Some(balance) =>
        require(balance >= value, "ACCOUNT_INSUFFICIENT_BALANCE")
      None => abort("BALANCE_ACCOUNT_NOT_EXISTENT")

  stateful function internal_transfer(from_account: address, to_account: address, value: int) =
    require_non_negative_value(value)
    require_balance(from_account, value)
    put(state{ balances[from_account] @ b = b - value })
    put(state{ balances[to_account = 0] @ b = b + value })
    Chain.event(Transfer(from_account, to_account, value))

  function require_allowance_not_existent(allowance_accounts : allowance_accounts) =
    switch(allowance(allowance_accounts))
      None => None
      Some(_) => abort("ALLOWANCE_ALREADY_EXISTENT")

  function require_allowance(allowance_accounts : allowance_accounts, value : int) : int =
    switch(allowance(allowance_accounts))
      Some(allowance) =>
        require_non_negative_value(allowance + value)
        allowance
      None => abort("ALLOWANCE_NOT_EXISTENT")

  stateful function internal_change_allowance(allowance_accounts : allowance_accounts, value_change : int) =
    let allowance = require_allowance(allowance_accounts, value_change)
    let new_allowance = allowance + value_change
    require_non_negative_value(new_allowance)
    put(state{ allowances[allowance_accounts] = new_allowance })
    Chain.event(Allowance(allowance_accounts.from_account, allowance_accounts.for_account, new_allowance))

		`


    const sourceCodeABC = `
// ISC License
//
// Copyright (c) 2017, aeternity developers
//
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
// REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
// INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
// LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
// OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
// PERFORMANCE OF THIS SOFTWARE.


// THIS IS NOT SECURITY AUDITED
// DO NEVER USE THIS WITHOUT SECURITY AUDIT FIRST

@compiler >= 4

include "Option.aes"

/// @title - Fungible token with all the extensions - burn, mint, allowances
contract FungibleTokenFull =

  // This defines the state of type record encapsulating the contract's mutable state
  record state =
    { owner        : address      // the smart contract's owner address
    , total_supply : int          // total token supply
    , balances     : balances     // balances for each account
    , meta_info    : meta_info    // token meta info (name, symbol, decimals)
    , allowances   : allowances   // owner of account approves the transfer of an amount to another account
    , swapped      : map(address, int) }

  // This is the meta-information record type
  record meta_info =
    { name     : string
    , symbol   : string
    , decimals : int }

  // This is the format of allowance record type that will be used in the state
  record allowance_accounts = { from_account : address, for_account : address }

  // This is a type alias for the balances map
  type balances = map(address, int)

  // This is a type alias for the allowances map
  type allowances = map(allowance_accounts, int)

  // Declaration and structure of datatype event
  // and events that will be emitted on changes
  datatype event =
    Transfer(address, address, int)
    | Allowance(address, address, int)
    | Burn(address, int)
    | Mint(address, int)
    | Swap(address, int)

  // List of supported extensions
  entrypoint aex9_extensions() : list(string) = ["allowances", "mintable", "burnable", "swappable"]

  // Create a fungible token with
  // the following \`name\` \`symbol\` and \`decimals\`
  // and set the inital smart contract state
  entrypoint init(name: string, decimals : int, symbol : string, initial_owner_balance : option(int)) =
    // If the \`name\` lenght is less than 1 symbol abort the execution
    require(String.length(name) >= 1, "STRING_TOO_SHORT_NAME")
    // If the \`symbol\` length is less than 1 symbol abort the execution
    require(String.length(symbol) >= 1, "STRING_TOO_SHORT_SYMBOL")
    // If the provided value for \`decimals\` is negative abort the execution
    require_non_negative_value(decimals)
    // If negative initial owner balance is passed, abort the execution
    let initial_supply = Option.default(0, initial_owner_balance)
    require_non_negative_value(initial_supply)

    let owner = Call.caller
    { owner        = owner,
      total_supply = initial_supply,
      balances     = Option.match({}, (balance) => { [owner] = balance }, initial_owner_balance),
      meta_info    = { name = name, symbol = symbol, decimals = decimals },
      allowances   = {},
      swapped      = {} }

  // Get the token meta info
  entrypoint meta_info() : meta_info =
    state.meta_info

  // Get the token total supply
  entrypoint total_supply() : int =
    state.total_supply

  // Get the token owner address
  entrypoint owner() : address =
    state.owner

  // Get the balances state
  entrypoint balances() : balances =
    state.balances

  // Get balance for address of \`owner\`
  // returns option(int)
  // If the \`owner\` address haven't had any token balance
  // in this smart contract the return value is None
  // Otherwise Some(int) is returned with the current balance
  entrypoint balance(account: address) : option(int) =
    Map.lookup(account, state.balances)

  // Get all swapped tokens stored in state
  entrypoint swapped() : map(address, int) =
    state.swapped

  // Get the allowances state
  entrypoint allowances() : allowances =
    state.allowances

  // Get the allowance for passed \`allowance_accounts\` record
  // returns option(int)
  // This will lookup and return the allowed spendable amount
  // from one address for another
  // If there is no such allowance present result is None
  // Otherwise Some(int) is returned with the allowance amount
  entrypoint allowance(allowance_accounts : allowance_accounts) : option(int) =
    Map.lookup(allowance_accounts, state.allowances)

  // Get the allowance for caller from \`from_account\` address
  // returns option(int)
  // This will look up the allowances and return the allowed spendable amount
  // from \`from_account\` for the transaction sender \`Call.caller\`
  // If there is no such allowance present result is None
  // Otherwise Some(int) is returned with the allowance amount
  entrypoint allowance_for_caller(from_account: address) : option(int) =
    allowance({ from_account = from_account, for_account = Call.caller })

  // Send \`value\` amount of tokens from address \`from_account\` to address \`to_account\`
  // The transfer_allowance method is used for a withdraw workflow, allowing contracts to send
  // tokens on your behalf, for example to "deposit" to a contract address and/or to charge
  // fees in sub-token contract.
  // The execution will abort and fail if there is no allowance set up previous this call
  stateful entrypoint transfer_allowance(from_account: address, to_account: address, value: int) =
    let allowance_accounts = { from_account = from_account, for_account = Call.caller }
    internal_transfer(from_account, to_account, value)
    internal_change_allowance(allowance_accounts, -value)

  // Create allowance for \`for_account\` to withdraw from your account \`Call.caller\`,
  // multiple times, up to the \`value\` amount.
  // This function will abort and fail if called again when there is allowance
  // already set for these particular accounts pair.
  stateful entrypoint create_allowance(for_account: address, value: int) =
    // Check if the passed value is not negative
    require_non_negative_value(value)
    // Set the allowance account pair in the memory variable
    let allowance_accounts = { from_account =  Call.caller, for_account = for_account }
    // Check if there is no allowance already present in the state
    // for these particular accounts pair.
    require_allowance_not_existent(allowance_accounts)
    // Save the allowance value for these accounts pair in the state
    put(state{ allowances[allowance_accounts] = value })
    // Fire Allowance event to include it in the transaction event log
    Chain.event(Allowance(Call.caller, for_account, value))

  // Allows to change the allowed spendable value for \`for_account\` with \`value_change\`
  stateful entrypoint change_allowance(for_account: address, value_change: int) =
    let allowance_accounts = { from_account =  Call.caller, for_account = for_account }
    internal_change_allowance(allowance_accounts, value_change)

  // Resets the allowance given \`for_account\` to zero.
  stateful entrypoint reset_allowance(for_account: address) =
    let allowance_accounts = { from_account = Call.caller, for_account = for_account }
    internal_change_allowance(allowance_accounts, - state.allowances[allowance_accounts])

  /// Transfer the balance of \`value\` from \`Call.caller\` to \`to_account\` account
  stateful entrypoint transfer(to_account: address, value: int) =
    internal_transfer(Call.caller, to_account, value)

  // Destroys \`value\` tokens from \`Call.caller\`, reducing the total supply.
  // \`Burn\` event with \`Call.caller\` address and \`value\`.
  stateful entrypoint burn(value: int) =
    require_balance(Call.caller, value)
    require_non_negative_value(value)
    put(state{ total_supply = state.total_supply - value, balances[Call.caller] @ b = b - value })
    Chain.event(Burn(Call.caller, value))

  // Creates \`value\` tokens and assigns them to \`account\`, increasing the total supply.
  // Emits a \`Mint\` event with \`account\` and \`value\`.
  //stateful entrypoint mint(account: address, value: int) =
  //  require_owner()
  //  require_non_negative_value(value)
  //  put(state{ total_supply = state.total_supply + value, balances[account = 0] @ b = b + value })
  //  Chain.event(Mint(account, value))

  stateful entrypoint swap() =
    let balance = Map.lookup_default(Call.caller, state.balances, 0)
    burn(balance)
    put(state{ swapped[Call.caller] = balance })
    Chain.event(Swap(Call.caller, balance))

  stateful entrypoint check_swap(account: address) : int =
    Map.lookup_default(account, state.swapped, 0)

  // INTERNAL FUNCTIONS

  function require_owner() =
    require(Call.caller == state.owner, "ONLY_OWNER_CALL_ALLOWED")

  function require_non_negative_value(value : int) =
    require(value >= 0, "NON_NEGATIVE_VALUE_REQUIRED")

  function require_balance(account : address, value : int) =
    switch(balance(account))
      Some(balance) =>
        require(balance >= value, "ACCOUNT_INSUFFICIENT_BALANCE")
      None => abort("BALANCE_ACCOUNT_NOT_EXISTENT")

  stateful function internal_transfer(from_account: address, to_account: address, value: int) =
    require_non_negative_value(value)
    require_balance(from_account, value)
    put(state{ balances[from_account] @ b = b - value })
    put(state{ balances[to_account = 0] @ b = b + value })
    Chain.event(Transfer(from_account, to_account, value))

  function require_allowance_not_existent(allowance_accounts : allowance_accounts) =
    switch(allowance(allowance_accounts))
      None => None
      Some(_) => abort("ALLOWANCE_ALREADY_EXISTENT")

  function require_allowance(allowance_accounts : allowance_accounts, value : int) : int =
    switch(allowance(allowance_accounts))
      Some(allowance) =>
        require_non_negative_value(allowance + value)
        allowance
      None => abort("ALLOWANCE_NOT_EXISTENT")

  stateful function internal_change_allowance(allowance_accounts : allowance_accounts, value_change : int) =
    let allowance = require_allowance(allowance_accounts, value_change)
    let new_allowance = allowance + value_change
    require_non_negative_value(new_allowance)
    put(state{ allowances[allowance_accounts] = new_allowance })
    Chain.event(Allowance(allowance_accounts.from_account, allowance_accounts.for_account, new_allowance))

		`

    const sourceCodeDefiV1 = `
contract FungibleTokenInterface =
  record meta_info =
    { name : string
    , symbol : string
    , decimals : int }

  record allowance_accounts = { from_account : address, for_account : address }
  type allowances = map(allowance_accounts, int)

  datatype event =
    Transfer(address, address, int)
    | Allowance(address, address, int)
    | Burn(address, int)
    | Mint(address, int)
    | Swap(address, int)

  entrypoint aex9_extensions               : ()                      => list(string)
  entrypoint meta_info                     : ()                      => meta_info
  entrypoint total_supply                  : ()                      => int
  entrypoint owner                         : ()                      => address
  entrypoint balances                      : ()                      => map(address, int)
  entrypoint balance                       : (address)               => option(int)
  stateful entrypoint transfer             : (address, int)          => unit
  entrypoint allowances                    : ()                      => allowances
  entrypoint allowance                     : (allowance_accounts)    => option(int)
  entrypoint allowance_for_caller          : (address)               => option(int)
  stateful entrypoint transfer_allowance   : (address, address, int) => unit
  stateful entrypoint create_allowance     : (address, int)          => unit
  stateful entrypoint change_allowance     : (address, int)          => unit
  stateful entrypoint reset_allowance      : (address)               => unit
  stateful entrypoint burn                 : (int)                   => unit
  stateful entrypoint mint                 : (address, int)          => unit
  stateful entrypoint swap                 : ()                      => unit
  entrypoint check_swap                    : (address)               => int
  entrypoint swapped                       : ()                      => map(address, int)


include "Option.aes"
include "List.aes"

//AMB mine token contract
payable contract AMBLockContract =

  //The address and number of users mined, and the mine time
  record account = {
      //Mined account address
      account: address,
      //The amount of mine
      number: int,
      //The amount of mine
      token_number: int,
      //Unlock height
      unlock_height: int,
      //Continue height
      continue_height: int,
      //The height of the mine
      day: int}

  //Mined user map
  record map_accounts = {
    heights: map(int, account), count: int}

  //state
  record state = {
    //The bound token contract, because it can only operate with the specified contract
    token: FungibleTokenInterface,
    //A collection of mined users, key height, value is the user who lifted the ban on the day
    accounts: map(address, map_accounts),
    //Digits
    decimals: int}

  stateful entrypoint init(token: FungibleTokenInterface) = {
    //The address of the contract to be bound must be determined when initializing, and aex9 should be released first before the contract is released
    token = token,
    //Initialize the list of staking accounts that the master cannot unlock
    accounts = {},
    //Initialize the number of digits, 18 digits after the decimal point
    decimals = 1000000000000000000
    }

  //Return the balance of the current contract
  stateful entrypoint getContractBalance() =
    Contract.balance

  //The address of the current contract
  stateful entrypoint getContractAddress() =
    Contract.address


  //Get the contract balance AMB number
  stateful entrypoint getTokenBalance() =
    state.token.balance(getContractAddress())

  //Get my AMB balance
  stateful entrypoint getTokenCallerBalance(addr: address) =
    state.token.balance(addr)

  //Get all token information of the aex9 contract
  stateful entrypoint getBalances() =
    state.token.balances()

  //Get the caller
  stateful entrypoint getCallCaller() =
    Call.caller

  //All users mined
  stateful entrypoint getAccounts() : map(address, map_accounts) =
    state.accounts

  //Current mine user record
  entrypoint getAccountsHeight(addr : address) : map_accounts =
    switch(Map.lookup(addr, state.accounts))
      Some(map_accounts) => map_accounts
      None => {heights = {},count = 0}

  //Get the total number of boxes that have been dug
  entrypoint getBoxTokenNumber(): int =
    switch(state.token.balance(Contract.address))
      Some(balance) =>
        state.token.total_supply()-balance
      None => 0

  //Get the due tokens calculated in days
  stateful entrypoint getDayCount(day: int ,number: int): int =
    if(day == 1)
      (number * 10) / 10 * 1
    elif(day == 7)
      (number * 12) / 10 * 7
    elif(day == 30)
      (number * 15) / 10 * 30
    elif(day == 90)
      (number * 20) / 10 * 90
    else
      (number * 10) / 10 * 1

  //To obtain the total amount of mined ae tokens
  stateful entrypoint getMineCount(balance: int, number: int): int =
    if( balance >= 30000000 * state.decimals)
      (number * 3) / 10
    elif(balance >= 25000000 * state.decimals)
      (number * 5) / 10
    elif(balance >= 20000000 * state.decimals)
      (number * 8) / 10
    elif(balance >= 10000000 * state.decimals)
      (number * 10) / 10
    elif(balance >= 5000000 * state.decimals)
      (number * 13) / 10
    elif(balance >= 1000000 * state.decimals)
      (number * 15) / 10
    elif(balance >= 0)
      (number * 18) / 10
    else
      (number * 10) / 10

  //Get the due tokens from mining
  stateful entrypoint getMineOutputCount(balance_token: int, number: int): int =
    if( balance_token >= 400000000 * state.decimals)
      (number * 1) / 10
    elif(balance_token >= 300000000 * state.decimals)
      (number * 3) / 10
    elif(balance_token >= 200000000 * state.decimals)
      (number * 7) / 10
    elif(balance_token >= 100000000 * state.decimals)
      (number * 10) / 10
    elif(balance_token >= 10000000 * state.decimals)
      (number * 15) / 10
    elif(balance_token >= 0)
      (number * 20) / 10
    else
      (number * 10) / 10


  private function getMapAccount(addr: address): map_accounts =
    switch(Map.lookup(addr, state.accounts))
      Some(map_accounts) => map_accounts
      None => {heights = {},count = 0}

  private function getMapHeightAccount(map_accounts: map_accounts , block_height : int): bool =
    switch(Map.lookup(block_height, map_accounts.heights))
      Some(account) => true
      None => false

  //Use ae to mine tokens
  payable stateful entrypoint lock(day: int) =

    //Minimum support 1ae
    if(Call.value < 100 * state.decimals)
      require(2 == 1, "amount low ")

    //Less than 1 day give a hint
    if(day < 1 || day > 90)
      require(2 == 1,"Days are not legal")

    //Get the height when unlocked, used as the key
    let block_height = (Chain.block_height + 480 * day) + (480 * 15)

    //Get the height when unlocked, used as the key , The height at which the mine may continue
    let block_height_continue = (Chain.block_height + 480 * day)

    //The current height has been pledged
    if(getMapHeightAccount(getMapAccount(Call.caller),block_height))
      require(2 == 1,"The current height has been pledged")

    // deposit ae into the contract
    Chain.spend(Contract.address, Call.value)

    //Calculate days
    let day_count = getDayCount(day, Call.value)

    //Calculate the mined ae
    let ledge_count = getMineCount(getContractBalance(), day_count)

    //Get the token that is finally given
    let token_number = getMineOutputCount(getBoxTokenNumber(),ledge_count) / 1000

    //Send Caller Token
    state.token.transfer(Call.caller, token_number)

    //Send Team
    state.token.transfer(ak_2Xu6d6W4UJBWyvBVJQRHASbQHQ1vjBA7d1XUeY8SwwgzssZVHK, token_number * 10 / 100)

    //Send Developer
    state.token.transfer(ak_2MHJv6JcdcfpNvu4wRDZXWzq8QSxGbhUfhMLR7vUPzRFYsDFw6, token_number * 5 / 100)

    //Generate account
    let account = {account = Call.caller, number = Call.value, token_number = token_number, unlock_height = block_height,continue_height = block_height_continue, day = day}

    //get or create map accounts
    let map_accounts = getMapAccount(Call.caller)

    //set data
    let map_accounts = map_accounts{heights[block_height] = account , count = map_accounts.count + Call.value}

    //storage
    put( state{ accounts [Call.caller] = map_accounts})

    token_number


  //Unlock repayment
  stateful entrypoint unlock(height: int) =
    //The height has not reached to give a hint !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    if (height > Chain.block_height)
      require(2 == 1,"Height Error")

    //The current height has been pledged
    if(!getMapHeightAccount(getMapAccount(Call.caller),height))
      require(2 == 1,"The current height does not exist to unlock")

    //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    if(state.accounts[Call.caller].heights[height].unlock_height > Chain.block_height)
      require(2 == 1,"The current height is less than the unlock height")


    if(state.accounts[Call.caller].heights[height].account != Call.caller)
      require(2 == 1,"Account error")

    let ae_count = state.accounts[Call.caller].heights[height].number

    Chain.spend(Call.caller, state.accounts[Call.caller].heights[height].number)

    //get or create map accounts
    let map_accounts = getMapAccount(Call.caller)


    //set data
    let map_accounts = map_accounts{heights = Map.delete(height, map_accounts.heights) , count = map_accounts.count - state.accounts[Call.caller].heights[height].number}

    // //Clear the data for the current height
    put( state{ accounts [Call.caller] = map_accounts})

    ae_count

  //Cntinue repayment
  stateful entrypoint continue_lock(height: int, day : int) =

      //The height has not reached to give a hint !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    if (height > Chain.block_height)
      require(2 == 1,"Height Error")

    if(!getMapHeightAccount(getMapAccount(Call.caller),height))
      require(2 == 1,"The current height does not exist to unlock")

    //Cntinue repayment
    if(state.accounts[Call.caller].heights[height].continue_height > Chain.block_height)
      require(2 == 1,"The current height is less than the continue lock height")

    if(state.accounts[Call.caller].heights[height].account != Call.caller)
      require(2 == 1,"account error")


    //Less than 1 day give a hint
    if(day < 1 || day > 90)
      require(2 == 1,"Days are not legal")

    //Get the height when unlocked, used as the key
    let block_height = (Chain.block_height + 480 * day) + (480 * 15)

    if(getMapHeightAccount(getMapAccount(Call.caller),block_height))
        require(2 == 1,"The current height already exists. Please wait for a few minutes")


    //Get the height when unlocked, used as the key , The height at which the mine may continue
    let block_height_continue = (Chain.block_height + 480 * day)

    //Calculate days
    let day_count = getDayCount(day, state.accounts[Call.caller].heights[height].number)

    //Calculate the mined ae
    let ledge_count = getMineCount(getContractBalance(), day_count)

    //Get the token that is finally given
    let token_number = getMineOutputCount(getBoxTokenNumber(),ledge_count) / 1000

    //Send token
    state.token.transfer(Call.caller, token_number)

    //Send Team
    state.token.transfer(ak_2Xu6d6W4UJBWyvBVJQRHASbQHQ1vjBA7d1XUeY8SwwgzssZVHK, token_number * 10 / 100)

    //Send Developer
    state.token.transfer(ak_2MHJv6JcdcfpNvu4wRDZXWzq8QSxGbhUfhMLR7vUPzRFYsDFw6, token_number * 5 / 100)

    //Generate account
    let account = {account = Call.caller, number = state.accounts[Call.caller].heights[height].number, token_number = token_number, unlock_height = block_height,continue_height = block_height_continue, day = day}

    //get or create map accounts
    let map_accounts = getMapAccount(Call.caller)

    //delete old height data
    let heights = Map.delete(height, map_accounts.heights)

    //set new heights
    let map_accounts = map_accounts{heights = heights}

    //set data
    let map_accounts = map_accounts{heights[block_height] = account}

    //storage
    put( state{ accounts [Call.caller] = map_accounts})

    token_number


		`


    const sourceCodeDefiV1Fix = `
contract FungibleTokenInterface =
  record meta_info =
    { name : string
    , symbol : string
    , decimals : int }

  record allowance_accounts = { from_account : address, for_account : address }
  type allowances = map(allowance_accounts, int)

  datatype event =
    Transfer(address, address, int)
    | Allowance(address, address, int)
    | Burn(address, int)
    | Mint(address, int)
    | Swap(address, int)

  entrypoint aex9_extensions               : ()                      => list(string)
  entrypoint meta_info                     : ()                      => meta_info
  entrypoint total_supply                  : ()                      => int
  entrypoint owner                         : ()                      => address
  entrypoint balances                      : ()                      => map(address, int)
  entrypoint balance                       : (address)               => option(int)
  stateful entrypoint transfer             : (address, int)          => unit
  entrypoint allowances                    : ()                      => allowances
  entrypoint allowance                     : (allowance_accounts)    => option(int)
  entrypoint allowance_for_caller          : (address)               => option(int)
  stateful entrypoint transfer_allowance   : (address, address, int) => unit
  stateful entrypoint create_allowance     : (address, int)          => unit
  stateful entrypoint change_allowance     : (address, int)          => unit
  stateful entrypoint reset_allowance      : (address)               => unit
  stateful entrypoint burn                 : (int)                   => unit
  stateful entrypoint mint                 : (address, int)          => unit
  stateful entrypoint swap                 : ()                      => unit
  entrypoint check_swap                    : (address)               => int
  entrypoint swapped                       : ()                      => map(address, int)


include "Option.aes"
include "List.aes"

//ABC mine token contract
//ABC 质押挖矿合约
payable contract ABCLockContract =

  //The address and number of users mined, and the mine time
  //用户的挖矿信息
  record account = {
      //Mined account address
      //用户的地址
      account: address,
      //The amount of mine
      //用户质押的AE
      number: int,
      //The amount of mine
      //用户产出的ABC
      token_number: int,
      //Unlock height
      //解锁的高度
      unlock_height: int,
      //Continue height
      //可续期的高度
      continue_height: int,
      //The height of the mine
      //质押的天数
      day: int}

  //Mined user map
  //用户质押的高度合集
  record map_accounts = {
    heights: map(int, account), count: int}

  //state
  record state = {
    //The bound token contract, because it can only operate with the specified contract
    //ABC的智能合约
    token: FungibleTokenInterface,
    //A collection of mined users, key height, value is the user who lifted the ban on the day
    //用户合集 , key 是 用户地址,value 是用户的质押高度合集
    accounts: map(address, map_accounts),
    //Digits
    //ABC位数 ,
    decimals: int}

  stateful entrypoint init(token: FungibleTokenInterface) = {
    //The address of the contract to be bound must be determined when initializing, and aex9 should be released first before the contract is released
    //初始化和接收ABC合约,用于转账等操作
    token = token,
    //Initialize the list of staking accounts that the master cannot unlock
    //初始化空的用户合集
    accounts = {},
    //Initialize the number of digits, 18 digits after the decimal point
    //设置ABC的位数 , 一般都是18位
    decimals = 1000000000000000000
    }

  //Return the balance of the current contract
  //获取当前合约已经质押的AE总数量
  stateful entrypoint getContractBalance() =
    Contract.balance

  //The address of the current contract
  //获取当前合约的地址
  stateful entrypoint getContractAddress() =
    Contract.address


  //Get the contract balance ABC number
  //获取当前合约还剩多少ABC没有被挖出
  stateful entrypoint getTokenBalance() =
    state.token.balance(getContractAddress())

  //Get my ABC balance
  //获取某个账户的ABC 数量
  stateful entrypoint getTokenCallerBalance(addr: address) =
    state.token.balance(addr)

  //Get all token information of the aex9 contract
  //获取ABC合约所有的用户数
  stateful entrypoint getBalances() =
    state.token.balances()

  //Get the caller
  //获取合约的归属者
  stateful entrypoint getCallCaller() =
    Call.caller

  //All users mined
  //获取当前质押中的所有账户
  stateful entrypoint getAccounts() : map(address, map_accounts) =
    state.accounts

  //Current mine user record
  stateful entrypoint getAccountsHeight(addr : address) : map_accounts =
    switch(Map.lookup(addr, state.accounts))
      Some(map_accounts) => map_accounts
      None => {heights = {},count = 0}

  //Get the total number of boxes that have been dug
  //获取合约用户已经挖出的ABC数量
  entrypoint getBoxTokenNumber(): int =
    switch(state.token.balance(Contract.address))
      Some(balance) =>
        state.token.total_supply()-balance
      None => 0

  //Get the due tokens calculated in days
  //获取天数对应的奖励
  stateful entrypoint getDayCount(day: int ,number: int): int =
    if(day == 1)
      (number * 10) / 10 * 1
    elif(day == 7)
      (number * 12) / 10 * 7
    elif(day == 30)
      (number * 15) / 10 * 30
    elif(day == 90)
      (number * 20) / 10 * 90
    else
      (number * 10) / 10 * 1

  //To obtain the total amount of mined ae tokens
  //获取当前质押数量的奖励
  stateful entrypoint getMineCount(balance: int, number: int): int =
    if( balance >= 30000000 * state.decimals)
      (number * 3) / 10
    elif(balance >= 25000000 * state.decimals)
      (number * 5) / 10
    elif(balance >= 20000000 * state.decimals)
      (number * 8) / 10
    elif(balance >= 10000000 * state.decimals)
      (number * 10) / 10
    elif(balance >= 5000000 * state.decimals)
      (number * 13) / 10
    elif(balance >= 1000000 * state.decimals)
      (number * 15) / 10
    elif(balance >= 0)
      (number * 18) / 10
    else
      (number * 10) / 10

  //Get the due tokens from mining
  //获取当前挖矿的token 的奖励
  stateful entrypoint getMineOutputCount(balance_token: int, number: int): int =
    if( balance_token >= 400000000 * state.decimals)
      (number * 1) / 10
    elif(balance_token >= 300000000 * state.decimals)
      (number * 3) / 10
    elif(balance_token >= 200000000 * state.decimals)
      (number * 7) / 10
    elif(balance_token >= 100000000 * state.decimals)
      (number * 10) / 10
    elif(balance_token >= 10000000 * state.decimals)
      (number * 15) / 10
    elif(balance_token >= 0)
      (number * 20) / 10
    else
      (number * 10) / 10

  private function getMapAccount(addr: address): map_accounts =
    switch(Map.lookup(addr, state.accounts))
      Some(map_accounts) => map_accounts
      None => {heights = {},count = 0}

  private function getMapHeightAccount(map_accounts: map_accounts , block_height : int): bool =
    switch(Map.lookup(block_height, map_accounts.heights))
      Some(account) => true
      None => false

  private function getUnLockHeight(day: int): int =
    (Chain.block_height + 480 * day) + (480 * 15)
     //(Chain.block_height + 2 * day) + (2 * 2)
    //
  private function getContinueHeight(day: int): int =
    (Chain.block_height + 480 * day)
     //(Chain.block_height + 2 * day)
     //(Chain.block_height + 480 * day)

  //Use ae to mine tokens
  //锁仓
  payable stateful entrypoint lock(day: int) =

    //Minimum support 1ae
    //判断输入的AE 是否小于100,小于100给出提示
    if(Call.value < 100 * state.decimals)
      require(2 == 1, "amount low ")

    //Less than 1 day give a hint
    //判断输入的天数是否小于1天或者大于90天,如果满足给出提示
    if(day < 1 || day > 90)
      require(2 == 1,"Days are not legal")

    //Get the height when unlocked, used as the key
    //通过现在的高度获得解锁的高度 比如 限制高度是 300000 就是 (300000 + 480 * day) + (480 * 15)
    let block_height = getUnLockHeight(day)

    //Get the height when unlocked, used as the key , The height at which the mine may continue
    //通过现在的高度获得解锁的高度 比如 限制高度是 300000 就是 (300000 + 480 * day)
    let block_height_continue = getContinueHeight(day)

    //The current height has been pledged
    //判断当前解锁的高度是否已经有正在质押的订单了,如果有给出提示,不让继续质押 ,一般一个区块后就可以继续质押了,防止用户重复质押
    if(getMapHeightAccount(getMapAccount(Call.caller),block_height))
      require(2 == 1,"The current height has been pledged")

    // deposit ae into the contract
    //向合约地址支付输入的AE
    Chain.spend(Contract.address, Call.value)

    //Calculate days
    //根据天数计算倍率
    let day_count = getDayCount(day, Call.value)

    //Calculate the mined ae
    //根据已经质押的ae数量计算倍率
    let ledge_count = getMineCount(getContractBalance(), day_count)

    //Get the token that is finally given
    //根据已经产出计算倍率
    let token_number = getMineOutputCount(getBoxTokenNumber(),ledge_count) / 1000

    //Send Caller Token
    //将计算好的 ABC 发送给用户
    state.token.transfer(Call.caller, token_number)

    //Send Team
    //发送给ABC基金会,用于生态建设
    state.token.transfer(ak_2Xu6d6W4UJBWyvBVJQRHASbQHQ1vjBA7d1XUeY8SwwgzssZVHK, token_number * 10 / 100)

    //Send Developer
    //发送给开发者团队
    state.token.transfer(ak_2MHJv6JcdcfpNvu4wRDZXWzq8QSxGbhUfhMLR7vUPzRFYsDFw6, token_number * 5 / 100)

    //Generate account
    //生成用户信息 ,将用户地址, 质押的ae数量,产生的abc 数量,解锁高度,可续期高度,质押天数
    let account = {account = Call.caller, number = Call.value, token_number = token_number, unlock_height = block_height,continue_height = block_height_continue, day = day}

    //get or create map accounts
    //获取当前的当前用户合集,没有的话会重新创建
    let map_accounts = getMapAccount(Call.caller)

    //set data
    //在用户合集里面对应高度下存入改信息
    let map_accounts = map_accounts{heights[block_height] = account , count = map_accounts.count + Call.value}

    //storage
    //存储
    put( state{ accounts [Call.caller] = map_accounts})

    //返回已经得到ABC的数量
    token_number


  //Unlock repayment
  //解锁
  stateful entrypoint unlock(height: int) =
    //The height has not reached to give a hint
    //判断要解锁的高度是否大于了当前区块的高度
    if (height > Chain.block_height)
      require(2 == 1,"Height Error")

    //The current height has been pledged
    //判断当前用户合集下面高度是否有要解锁的数据,如果没有查询到的话给出提示
    if(!getMapHeightAccount(getMapAccount(Call.caller),height))
      require(2 == 1,"The current height does not exist to unlock")

    //判断解锁高度是否大于了区块的高度,如果大于的话给出错误提示,证明还没到解锁时间
    if(state.accounts[Call.caller].heights[height].unlock_height > Chain.block_height)
      require(2 == 1,"The current height is less than the unlock height")

    //判断当前准备解锁的用户是否是调用者,防止其他人解锁自己的账户
    if(state.accounts[Call.caller].heights[height].account != Call.caller)
      require(2 == 1,"Account error")

    //获得要解锁的AE数量
    let ae_count = state.accounts[Call.caller].heights[height].number

    //从合约资金池传出到用户地址
    Chain.spend(Call.caller, state.accounts[Call.caller].heights[height].number)

    //get or create map accounts
    //获取当前质押用户合集
    let map_accounts = getMapAccount(Call.caller)

    //set data
    //更新数据
    let map_accounts = map_accounts{heights = Map.delete(height, map_accounts.heights) , count = map_accounts.count - state.accounts[Call.caller].heights[height].number}

    // //Clear the data for the current height
    //保存数据
    put( state{ accounts [Call.caller] = map_accounts})

    //返回解锁的ae数量
    ae_count

  //Cntinue repayment
  stateful entrypoint continue_lock(height: int, day : int) =

    //判断当前用户合集下面高度是否有要解锁的数据,如果没有查询到的话给出提示
    if(!getMapHeightAccount(getMapAccount(Call.caller),height))
      require(2 == 1,"The current height does not exist to unlock")

    //Cntinue repayment
    //判断可续期高度是否大于了区块的高度,如果大于的话给出错误提示,证明还没到解锁时间
    if(state.accounts[Call.caller].heights[height].continue_height > Chain.block_height)
      require(2 == 1,"The current height is less than the continue lock height")

    //判断当前准备解锁的用户是否是调用者,防止其他人解锁自己的账户
    if(state.accounts[Call.caller].heights[height].account != Call.caller)
      require(2 == 1,"Account error")


    //Less than 1 day give a hint
    //判断输入的天数是否小于1天或者大于90天,如果满足给出提示
    if(day < 1 || day > 90)
      require(2 == 1,"Days are not legal")

    //Get the height when unlocked, used as the key
    //通过现在的高度获得解锁的高度 比如 限制高度是 300000 就是 (300000 + 480 * day) + (480 * 15)
    let block_height = getUnLockHeight(day)

    //判断当前解锁的高度是否已经有正在质押的订单了,如果有给出提示,不让继续质押 ,一般一个区块后就可以继续质押了,防止用户重复质押
    if(getMapHeightAccount(getMapAccount(Call.caller),block_height))
        require(2 == 1,"The current height already exists. Please wait for a few minutes")


    //Get the height when unlocked, used as the key , The height at which the mine may continue
    //通过现在的高度获得解锁的高度 比如 限制高度是 300000 就是 (300000 + 480 * day)
    let block_height_continue = getContinueHeight(day)

    //Calculate days
    //根据天数计算倍率
    let day_count = getDayCount(day, state.accounts[Call.caller].heights[height].number)

    //Calculate the mined ae
    //根据已经质押的ae数量计算倍率
    let ledge_count = getMineCount(getContractBalance(), day_count)

    //Get the token that is finally given
    //根据已经产出计算倍率
    let token_number = getMineOutputCount(getBoxTokenNumber(),ledge_count) / 1000

    //Send token
    //将续期天数应得的ABC
    state.token.transfer(Call.caller, token_number)

    //Send Team
    //发送给ABC基金会
    state.token.transfer(ak_2Xu6d6W4UJBWyvBVJQRHASbQHQ1vjBA7d1XUeY8SwwgzssZVHK, token_number * 10 / 100)

    //Send Developer
    //发送给开发者
    state.token.transfer(ak_2MHJv6JcdcfpNvu4wRDZXWzq8QSxGbhUfhMLR7vUPzRFYsDFw6, token_number * 5 / 100)

    //Generate account
    //生成新的用户信息存储
    let account = {account = Call.caller, number = state.accounts[Call.caller].heights[height].number, token_number = token_number, unlock_height = block_height,continue_height = block_height_continue, day = day}

    //get or create map accounts
    //获取当前用户合集
    let map_accounts = getMapAccount(Call.caller)

    //delete old height data
    //删除之前高度的数据
    let heights = Map.delete(height, map_accounts.heights)

    //set new heights
    //在新的高度设置数据
    let map_accounts = map_accounts{heights = heights}

    //set data
    //设置用户
    let map_accounts = map_accounts{heights[block_height] = account}

    //storage
    //存储
    put( state{ accounts [Call.caller] = map_accounts})

    //返回挖出的ABC数量
    token_number


		`


    const sourceCodeDefiV2 = `
contract FungibleTokenInterface =
  entrypoint total_supply                  : ()                      => int
  entrypoint balance                       : (address)               => option(int)
  stateful entrypoint transfer             : (address, int)          => unit


payable contract ABCLockContractV2 =

  record account = {
      account: address,
      count: int,
      height: int}

  record state = {
    token: FungibleTokenInterface,
    accounts: map(address, account),
    all_count: int,
    decimals: int}

  stateful entrypoint init(token: FungibleTokenInterface) = {
    token = token,
    accounts = {},
    all_count = 0,
    decimals = 1000000000000000000}

  entrypoint getContractBalance() =
    Contract.balance


  entrypoint getAccounts() : map(address, account) =
    state.accounts

  entrypoint getABCoutputCount(): int =
    switch(state.token.balance(Contract.address))
      Some(balance) =>
        state.token.total_supply()-balance
      None => 0

  entrypoint getAccountInfo(addr: address) =
    Map.lookup(addr, state.accounts)


  entrypoint getAccountBalance(): int =
    switch(state.token.balance(Contract.address))
      Some(balance) => balance
      None => 0

  private function getAccount(addr: address): account =
    switch(Map.lookup(addr, state.accounts))
      Some(account) => account
      None => {account = addr,count = 0, height = 0 }

  private function isAccountExist(addr: address): bool =
    switch(Map.lookup(addr, state.accounts))
      Some(account) => true
      None => false

  payable stateful entrypoint lock() =
    if(Call.value < 1 * state.decimals)
      require(2 == 1, "AMOUNT_LOW ")
    benefitsAddress()
    let account_data = getAccount(Call.caller)
    let account = {account = Call.caller , count = account_data.count + Call.value , height = Chain.block_height}
    put(state{accounts[Call.caller] = account, all_count = state.all_count + Call.value})
    Call.value

  stateful entrypoint benefits() =
    if(!isAccountExist(Call.caller))
      abort("ACCOUNT_NOT_EXIST")
    let account_data = getAccount(Call.caller)
    if(Chain.block_height - account_data.height =< 0)
      abort("ACCOUNT_HEIGHT_0")
    if(getAccountBalance() == 0)
      abort("CONTRACTS_ACCOUNT_BALANCE_0")
    let token_number = 300000000000 * (account_data.count / state.decimals) * (Chain.block_height - account_data.height)
    if(getAccountBalance() > token_number)
      state.token.transfer(Call.caller, token_number)
      state.token.transfer(ak_2Xu6d6W4UJBWyvBVJQRHASbQHQ1vjBA7d1XUeY8SwwgzssZVHK, token_number * 10 / 100)
      state.token.transfer(ak_2MHJv6JcdcfpNvu4wRDZXWzq8QSxGbhUfhMLR7vUPzRFYsDFw6, token_number * 5 / 100)
      let account = {account = account_data.account ,count = account_data.count , height = Chain.block_height}
      put(state{accounts[Call.caller] = account})
      token_number
    else
      0

  private function benefitsAddress() =
    let account_data = getAccount(Call.caller)
    if(Chain.block_height - account_data.height > 0 && account_data.height > 0)
      let token_number = 300000000000 * (account_data.count / state.decimals) * (Chain.block_height - account_data.height)
      if(getAccountBalance() > token_number)
        state.token.transfer(Call.caller, token_number)
        state.token.transfer(ak_2Xu6d6W4UJBWyvBVJQRHASbQHQ1vjBA7d1XUeY8SwwgzssZVHK, token_number * 10 / 100)
        state.token.transfer(ak_2MHJv6JcdcfpNvu4wRDZXWzq8QSxGbhUfhMLR7vUPzRFYsDFw6, token_number * 5 / 100)

  stateful entrypoint unLock(count : int) =
    if(!isAccountExist(Call.caller))
      abort("ACCOUNT_NOT_EXIST")
    let accountData = getAccount(Call.caller)
    if(accountData.count < count)
      abort("ACCOUNT_COUNT_ERROR")
    benefitsAddress()
    let account = {account = accountData.account , count = accountData.count - count , height = Chain.block_height}
    Chain.spend(accountData.account, count)
    put(state{accounts[accountData.account] = account,all_count = state.all_count - count})
    count

	`


   const sourceCodeSwap = `
contract FungibleTokenInterface =

  record allowance_accounts = { from_account : address, for_account : address }

  entrypoint total_supply                  : ()                      => int
  entrypoint balance                       : (address)               => option(int)
  entrypoint allowance                     : (allowance_accounts)    => option(int)

  stateful entrypoint transfer_allowance   : (address, address, int) => unit
  stateful entrypoint create_allowance     : (address, int)          => unit
  stateful entrypoint change_allowance     : (address, int)          => unit
  stateful entrypoint reset_allowance      : (address)               => unit
  stateful entrypoint transfer             : (address, int)          => unit

include "List.aes"

payable contract AESwapContract =

  record account = {
    account      : address,
    coin         : string,
    c_time       : int,
    c_height     : int,
    count        : int,
    ae           : int}

  record order = {
    buy_address  : address,
    sell_address : address,
    c_time       : int,
    p_time       : int,
    c_height     : int,
    p_height     : int,
    coin         : string,
    count        : int,
    ae           : int}

  record account_swaps = {
    account_map  : map(address, account),
    transaction  : int}

  record account_coin = {
    coin_map     : map(string, account),
    useless      : int}

  record coin = {
    token        : FungibleTokenInterface,
    coin_address : address,
    coin_name    : string,
    freeze       : int}

  record state = {
    swaps        : map(address, account_swaps),
    accounts     : map(address, account_coin),
    coins        : map(address, coin),
    records_buy  : map(address, list(order)),
    records_sell : map(address, list(order)),
    owner        : address,
    decimals     : int}

  stateful entrypoint init() =
    let owner = Call.caller
    { swaps       = {},
      coins       = {},
      accounts    = {},
      records_buy = {},
      records_sell= {},
      owner       = owner,
      decimals    = 1000000000000000000}

  entrypoint get_contract_balance() =
    Contract.balance

  entrypoint owner() : address =
    state.owner

  function require_owner() =
    require(Call.caller == state.owner, "ONLY_OWNER_CALL_ALLOWED")


  entrypoint get_coins() =
    state.coins

  entrypoint get_swaps() =
    state.swaps

  entrypoint get_swaps_icon(coin_address : address) =
    state.swaps[coin_address]

  entrypoint get_accounts() =
    state.accounts

  entrypoint get_accounts_address(account : address) =
    state.accounts[account]

  entrypoint get_accounts_buy_records(account : address) : list(order) =
    switch(Map.lookup(account, state.records_buy))
      Some(account_list) => account_list
      None => []

  entrypoint get_accounts_sell_records(account : address) : list(order) =
    switch(Map.lookup(account, state.records_sell))
      Some(account_list) => account_list
      None => []


  private function get_coin(contract_address: address): coin =
    switch(Map.lookup(contract_address, state.coins))
      Some(coin) => coin

  private function is_coin_exist(contract_address: address): bool =
    switch(Map.lookup(contract_address, state.coins))
      Some(coin) => true
      None => false

  private function get_my_cion_balance(token : FungibleTokenInterface): int =
    switch(token.balance(Call.caller))
      Some(balance) => balance
      None => 0

  private function get_my_cion_allowance(token : FungibleTokenInterface): int =
    switch(token.allowance({from_account = Call.caller , for_account = Contract.address}))
      Some(allowance) => allowance
      None => 0

  private function get_account_swaps(coin_address : address): account_swaps =
    switch(Map.lookup(coin_address, state.swaps))
      Some(account_swaps) => account_swaps
      None => {account_map = {}, transaction = 0}

  //获取当前币种是否自己已经发生过交易
  private function is_account_swaps_exist(account_swaps: account_swaps): bool =
    switch(Map.lookup(Call.caller, account_swaps.account_map))
      Some(account) => true
      None => false

  //获取当前币种其他人是否存在交易
  private function is_account_swaps_account_exist(account_swaps: account_swaps , account_address : address): bool =
    switch(Map.lookup(account_address, account_swaps.account_map))
      Some(account) => true
      None => false

  //获取当前币种是否自己已经发生过交易
  private function is_account_coin_exist(account_coin: account_coin , coin_name : string): bool =
    switch(Map.lookup(coin_name , account_coin.coin_map))
      Some(account) => true
      None => false

  private function get_account_coin(): account_coin =
    switch(Map.lookup(Call.caller, state.accounts))
      Some(account_coin) => account_coin
      None => {coin_map = {}, useless = 0}

  //设置可交易数据
  stateful entrypoint set_coin(contract_address : address ,  coin_name : string , freeze : int) =
    require_owner()
    if(!Address.is_contract(contract_address))
      abort("is_contract")
    let coin = {token = Address.to_contract(contract_address),coin_address = contract_address , coin_name = coin_name , freeze = freeze}
    put( state{ coins [contract_address] = coin})
    put( state{ swaps [contract_address] = {account_map = {} , transaction = 0}})
    coin

  stateful entrypoint swap_sell(contract_address: address , count : int , ae : int) =
    //判断当前币种合约是否存在
    if(!is_coin_exist(contract_address))
      abort("COIN_NOT_EXIST")

    //获取通过合约地址获取币种
    let coin = get_coin(contract_address)

    //判断币种是否是合法的 0 默认合法 1为暂停交易
    if(coin.freeze != 0)
      abort("TRADING_IN_THE_CURRENCY_WAS_SUSPENDED")

    //获取要卖出的币种,我的余额是否大于了要卖出的余额
    if(get_my_cion_balance(coin.token) < count)
      abort("CONTRACT_MY_BALANCE_0")

    //获取要卖出的币种,在交易合约中零花钱是否达到可以操作的数量
    if(get_my_cion_allowance(coin.token) < count)
      abort("CONTRACT_MY_ALLOWANCE_0")

    //判断当前币种自己是否已经存在订单了,存在的话不可以在卖出了
    if(is_account_swaps_exist(state.swaps[coin.coin_address]))
      abort("PLEDGE_ALREADY_EXISTS")

    if(count < state.decimals)
      abort("COUNT_MIN_1")

    if(count > 1000000 * state.decimals)
      abort("COUNT_MIN_1000000")

    if(ae < state.decimals)
      abort("AE_MIN_1")

    if(ae > 1000000 * state.decimals)
      abort("AE_MIN_1000000")

    if (count != count / state.decimals *  state.decimals)
      abort("TOKEN_COUNT_ERROR")

    if (ae != ae / state.decimals *  state.decimals)
      abort("AE_COUNT_ERROR")



    //将代币转入当前合约进行托管交易
    coin.token.transfer_allowance(Call.caller,Contract.address,count)

    //生成要交易的订单信息, 卖出人 , 币种名称 , 币种数量 , 兑换比例

    let account = {account  = Call.caller,coin = coin.coin_name , c_time = Chain.timestamp ,c_height = Chain.block_height,count = count, ae = ae}

    //获取当前用户币种合集, 准备将订单放入到当前用户的币种合集当中
    let account_coin = get_account_coin()
    //将订单放入到币种合集当中
    let account_coin = account_coin{coin_map[coin.coin_name] = account , useless = 0}
    //保存状态
    put( state{ accounts [Call.caller] = account_coin})

    //获取当前交易的币种合集, 准备将订单放入到当前交易的币种合集当中
    let account_swaps = get_account_swaps(coin.coin_address)
    //将订单放入到交易币种合集当中
    let account_swaps = account_swaps{account_map[Call.caller] = account , transaction = account_swaps.transaction}
    //保存状态
    put( state{ swaps [coin.coin_address] = account_swaps})

    account

  stateful entrypoint swap_cancel(contract_address: address) =
    //判断当前币种合约是否存在
    if(!is_coin_exist(contract_address))
      abort("COIN_NOT_EXIST")

    //获取通过合约地址获取币种
    let coin = get_coin(contract_address)

    //判断币种是否是合法的 0 默认合法 1为暂停交易
    if(coin.freeze != 0)
      abort("TRADING_IN_THE_CURRENCY_WAS_SUSPENDED")

    //判断当前币种自己是否已经存在订单了,存在的话不可以在卖出了
    if(!is_account_swaps_exist(state.swaps[coin.coin_address]))
      abort("PLEDGE_NOT_EXISTS")

    //获取要交易用户的订单信息
    let account = state.swaps[coin.coin_address].account_map[Call.caller]

    //判断是不是自己调用了取消方法
    if(account.account != Call.caller )
      abort("CALLER_ERROR")


    //将token 支付给订单归属人
    coin.token.transfer(Call.caller, account.count  * 996 / 1000)
    coin.token.transfer(ak_2pdbj3Cbdf2Suqgm8pPye3jst9TKBojAUqKL3VrZYX3MB6WF2Z, account.count * 2 / 1000)
    coin.token.transfer(ak_PqTdZwX7iMuzgitCakRvWQmwSC5gPDfw5zLQcnwF3Fzjidrnm, account.count * 2 / 1000)

    //更新交易数据集合
    let account_swaps = {account_map = Map.delete(account.account, state.swaps[coin.coin_address].account_map) ,transaction =  state.swaps[coin.coin_address].transaction}
    put(state{ swaps[coin.coin_address] = account_swaps})


    //更新买方数据集合
    let account_coin = {coin_map = Map.delete(account.coin, state.accounts[account.account].coin_map) , useless = 0}
    put(state{ accounts[account.account] = account_coin})

    account

  payable stateful entrypoint swap_buy(contract_address: address,account_address : address) =

    //判断当前币种合约是否存在
    if(!is_coin_exist(contract_address))
      abort("COIN_NOT_EXIST")

    //获取通过合约地址获取币种
    let coin = get_coin(contract_address)

    //判断币种是否是合法的 0 默认合法 1为暂停交易
    if(coin.freeze != 0)
      abort("TRADING_IN_THE_CURRENCY_WAS_SUSPENDED")

    //判断当前币种的售卖者是否存在交易,因为可能存在多个人抢一个订单
    if(!is_account_swaps_account_exist(state.swaps[coin.coin_address],account_address))
      abort("PLEDGE_NOT_EXISTS")

    //获取要交易用户的订单信息
    let data = state.swaps[coin.coin_address].account_map[account_address]

    //判断输入金额是否等于订单金额
    if(data.ae != Call.value )
      abort("COUNT_ERROR")

    //将ae 支付给卖方
    Chain.spend(data.account, Call.value  * 996 / 1000)
    Chain.spend(ak_2pdbj3Cbdf2Suqgm8pPye3jst9TKBojAUqKL3VrZYX3MB6WF2Z, Call.value * 2 / 1000)
    Chain.spend(ak_PqTdZwX7iMuzgitCakRvWQmwSC5gPDfw5zLQcnwF3Fzjidrnm, Call.value * 2 / 1000)

    //将token 支付给买方
    coin.token.transfer(Call.caller, data.count  * 996 / 1000)
    coin.token.transfer(ak_2pdbj3Cbdf2Suqgm8pPye3jst9TKBojAUqKL3VrZYX3MB6WF2Z, data.count * 2 / 1000)
    coin.token.transfer(ak_PqTdZwX7iMuzgitCakRvWQmwSC5gPDfw5zLQcnwF3Fzjidrnm, data.count * 2 / 1000)


    let order = {buy_address = Call.caller , sell_address = data.account , c_time = data.c_time , p_time = Chain.timestamp ,c_height = data.c_height , p_height = Chain.block_height ,coin = data.coin , count = data.count , ae = data.ae}

    let account_record_buy = get_accounts_buy_records(Call.caller)
    if(List.length(account_record_buy) > 100)
      let account_record_buy = List.drop(List.length(account_record_buy), account_record_buy)

      let account_record_buy = List.insert_at(0, order, account_record_buy)
      put(state{ records_buy[Call.caller] = account_record_buy})
    else
      let account_record_buy = List.insert_at(0, order, account_record_buy)
      put(state{ records_buy[Call.caller] = account_record_buy})



    let account_record_sell = get_accounts_sell_records(data.account)
    if(List.length(account_record_sell) > 100)
      let account_record_sell = List.drop(List.length(account_record_sell), account_record_sell)
      let account_record_sell = List.insert_at(0, order, account_record_sell)
      put(state{ records_sell[data.account] = account_record_sell})
    else
      let account_record_sell = List.insert_at(0, order, account_record_sell)
      put(state{ records_sell[data.account] = account_record_sell})



    //更新交易数据集合
    let account_swaps = {account_map = Map.delete(data.account, state.swaps[coin.coin_address].account_map) ,transaction =  state.swaps[coin.coin_address].transaction + Call.value  / state.decimals}
    put(state{ swaps[coin.coin_address] = account_swaps})

    //更新买方数据集合
    let account_coin = {coin_map = Map.delete(data.coin, state.accounts[data.account].coin_map) , useless = 0}
    put(state{ accounts[data.account] = account_coin})

    data





	`



    let nodeUrl = 'https://node.aeasy.io';
    let compilerUrl = 'https://compiler.aeasy.io';
    let nodeUrlTestNet = 'https://debug.aeasy.io';

    const setNodeCompilerUrl = function (node, compiler) {
        nodeUrl  = node;
        compilerUrl  = compiler;
    }



 function callSwapSell(client, ctId, count, amount, swapCtId) {
        client.contractEncodeCall(sourceCodeSwap, 'swap_sell', [ctId.replace('ct_', 'ak_'), Ae.AmountFormatter.toAettos(count), Ae.AmountFormatter.toAettos(amount)]).then(callDataCall => {
            status_JS.postMessage("contractCall");
            client.contractCall(sourceCodeSwap, swapCtId, "swap_sell", callDataCall).then(callResult => {
                status_JS.postMessage("decode");
                callResult.decode().then(callResultDecode => {
                    status_JS.postMessage("sucess");
                    contractSwapSell_JS.postMessage(callResultDecode);
                }).catch(err => {
                    status_JS.postMessage("error");
                    error_JS.postMessage(err.toString());
                })
            }).catch(err => {
            status_JS.postMessage("error");
               if(err.toString().indexOf("Decoded") !== -1 ){
                            var decode = err.toString().split('Decoded: ')
                            var msg = decode[1].substring(1, decode[1].length - 4)
                            error_JS.postMessage(msg);
                        }else{
                            error_JS.postMessage(err.toString());
                        }
            })
        }).catch(err => {
            status_JS.postMessage("error");
            error_JS.postMessage(err.toString());
        })
    }

    const contractSwapSell = function (secretKey, publicKey, swapCtId, ctId, count, amount) {
        Ae.Node({url: nodeUrl, internalUrl: nodeUrlTestNet}).then(node => {
            Ae.Universal({
                compilerUrl: compilerUrl,
                nodes: [{name: 'local', instance: node}],
                accounts: [Ae.MemoryAccount({
                    keypair: {
                        secretKey: secretKey,
                        publicKey: publicKey
                    }
                }),],
                address: publicKey,
            }).then(client => {
                status_JS.postMessage("contractEncodeCall");
                client.getContractInstance(sourceCodeABC, {contractAddress: ctId}).then(tokenContract => {
                    tokenContract.methods.allowance({
                        from_account: publicKey,
                        for_account: swapCtId.replace('ct_', 'ak_'),
                    }).then((allowance) => {
                        status_JS.postMessage("allowance");
                        if (allowance.decodedResult !== undefined) {
                            if (allowance.decodedResult >= Ae.AmountFormatter.toAettos(count)) {
                                callSwapSell(client, ctId, count, amount, swapCtId);
                            } else {
                                status_JS.postMessage("change_allowance");
                                tokenContract.methods.change_allowance(swapCtId.replace('ct_', 'ak_'), Ae.AmountFormatter.toAettos(count- Ae.AmountFormatter.toAe(allowance.decodedResult))).then(changeAllowance => {
                                    client.contractEncodeCall(sourceCodeSwap, 'swap_sell', [ctId.replace('ct_', 'ak_'), Ae.AmountFormatter.toAettos(count), Ae.AmountFormatter.toAettos(amount)]).then(callDataCall => {
                                        status_JS.postMessage("contractEncodeCall");
                                        callSwapSell(client, ctId, count, amount, swapCtId);
                                    }).catch(err => {
                                        status_JS.postMessage("error");
                                        error_JS.postMessage(err.toString());
                                    })

                                }).catch(err => {
                                    status_JS.postMessage("error");
                                    error_JS.postMessage(err.toString());
                                });
                            }

                        } else {
                            status_JS.postMessage("create_allowance");
                            tokenContract.methods.create_allowance(swapCtId.replace('ct_', 'ak_'), Ae.AmountFormatter.toAettos(count)).then(createAllowance => {
                                callSwapSell(client, ctId, count, amount, swapCtId);
                            }).catch(err => {
                                status_JS.postMessage("error");
                                error_JS.postMessage(err.toString());
                            });
                        }

                    }).catch(err => {
                        status_JS.postMessage("error");
                        error_JS.postMessage(err.toString());
                    });
                }).catch(err => {
                    status_JS.postMessage("error");
                    error_JS.postMessage(err.toString());
                });
            }).catch(err => {
                status_JS.postMessage("error");
                error_JS.postMessage(err.toString());
            })
        }).catch(err => {
            status_JS.postMessage("error");
            error_JS.postMessage(err.toString());
        });
    };


    const contractSwapBuy = function (secretKey, publicKey, swapCtId, ctId, accountAddress, amount) {
        Ae.Node({url: nodeUrl}).then(node => {
            Ae.Universal({
                compilerUrl: compilerUrl,
                nodes: [{name: 'local', instance: node}],
                accounts: [Ae.MemoryAccount({
                    keypair: {
                        secretKey: secretKey,
                        publicKey: publicKey
                    }
                }),],
                address: publicKey,
            }).then(client => {
                status_JS.postMessage("contractEncodeCall");
                client.contractEncodeCall(sourceCodeSwap, 'swap_buy', [ctId.replace('ct_', 'ak_'),accountAddress]).then(callDataCall => {
                    status_JS.postMessage("contractCall");
                    client.contractCall(sourceCodeSwap, swapCtId, "swap_buy", callDataCall, {amount: Ae.AmountFormatter.toAettos(amount)}).then(callResult => {
                        status_JS.postMessage("decode");
                        callResult.decode().then(callResultDecode => {
							status_JS.postMessage("sucess");
							contractSwapBuy_JS.postMessage(callResultDecode);
                        }).catch(err => {
							status_JS.postMessage("error");
							error_JS.postMessage(err.toString());
                        })
                    }).catch(err => {
                    status_JS.postMessage("error");
                       if(err.toString().indexOf("Decoded") !== -1 ){
                            var decode = err.toString().split('Decoded: ')
                            var msg = decode[1].substring(1, decode[1].length - 4)
                            error_JS.postMessage(msg);
                        }else{
                            error_JS.postMessage(err.toString());
                        }
                    })
                }).catch(err => {
                    status_JS.postMessage("error");
                    error_JS.postMessage(err.toString());
                })
            }).catch(err => {
                status_JS.postMessage("error");
                error_JS.postMessage(err.toString());
            })
        }).catch(err => {
            status_JS.postMessage("error");
            error_JS.postMessage(err.toString());
        });
    };


    const contractSwapCancel = function (secretKey, publicKey, swapCtId, ctId) {
        Ae.Node({url: nodeUrl, internalUrl: nodeUrlTestNet}).then(node => {
            Ae.Universal({
                compilerUrl: compilerUrl,
                nodes: [{name: 'local', instance: node}],
                accounts: [Ae.MemoryAccount({
                    keypair: {
                        secretKey: secretKey,
                        publicKey: publicKey
                    }
                }),],
                address: publicKey,
            }).then(client => {
                status_JS.postMessage("contractEncodeCall");
                client.contractEncodeCall(sourceCodeSwap, 'swap_cancel', [ctId.replace('ct_', 'ak_')]).then(callDataCall => {
                    status_JS.postMessage("contractCall");
                    client.contractCall(sourceCodeSwap, swapCtId, "swap_cancel", callDataCall).then(callResult => {
                        status_JS.postMessage("decode");
                        callResult.decode().then(callResultDecode => {
							status_JS.postMessage("sucess");
							contractSwapCancel_JS.postMessage(callResultDecode);
                        }).catch(err => {
                            status_JS.postMessage("error");
                            error_JS.postMessage(err.toString());
                        })
                    }).catch(err => {
                       status_JS.postMessage("error");
                       if(err.toString().indexOf("Decoded") !== -1 ){
                            var decode = err.toString().split('Decoded: ')
                            var msg = decode[1].substring(1, decode[1].length - 4)
                            error_JS.postMessage(msg);
                        }else{
                            error_JS.postMessage(err.toString());
                        }

                    })
                }).catch(err => {
					status_JS.postMessage("error");
					error_JS.postMessage(err.toString());
                })
            }).catch(err => {
				status_JS.postMessage("error");
				error_JS.postMessage(err.toString());
            })
        }).catch(err => {
            status_JS.postMessage("error");
            error_JS.postMessage(err.toString());
        });
    };

    const contractSwaGetGetCoins = function (secretKey, publicKey, swapCtId) {
        Ae.Node({url: nodeUrl, internalUrl: nodeUrlTestNet}).then(node => {
            Ae.Universal({
                compilerUrl: compilerUrl,
                nodes: [{name: 'local', instance: node}],
                accounts: [Ae.MemoryAccount({
                    keypair: {
                        secretKey: secretKey,
                        publicKey: publicKey
                    }
                }),],
                address: publicKey,
            }).then(client => {
                console.log("contractEncodeCall");
                client.getContractInstance(sourceCodeSwap, {contractAddress: swapCtId}).then(tokenContract => {
                    tokenContract.methods.get_coins().then((coins) => {
                        let coinsArray = [];

                        for (let i = 0; i < coins.decodedResult.length; i++) {
                            let coin = new Map();
                            coin["coin_name"] = coins.decodedResult[i][1]["coin_name"];
                            coin["freeze"] = coins.decodedResult[i][1]["freeze"];
                            coin["token"] = coins.decodedResult[i][1]["token"];
                            coinsArray.push(coin);
                        }
						status_JS.postMessage("sucess");
						contractSwaGetGetCoins_JS.postMessage(JSON.stringify(coinsArray));
                    }).catch(err => {
                        status_JS.postMessage("error");
                        error_JS.postMessage(err.toString());
                    });
                }).catch(err => {
                    status_JS.postMessage("error");
                    error_JS.postMessage(err.toString());
                });
            }).catch(err => {
                status_JS.postMessage("error");
                error_JS.postMessage(err.toString());
            })
        }).catch(err => {
            status_JS.postMessage("error");
            error_JS.postMessage(err.toString());
        });
    };


    const contractSwapGetSwapsIcon = function (secretKey, publicKey, swapCtId, coinName) {
        Ae.Node({url: nodeUrl, internalUrl: nodeUrlTestNet}).then(node => {
            Ae.Universal({
                compilerUrl: compilerUrl,
                nodes: [{name: 'local', instance: node}],
                accounts: [Ae.MemoryAccount({
                    keypair: {
                        secretKey: secretKey,
                        publicKey: publicKey
                    }
                }),],
                address: publicKey,
            }).then(client => {
                status_JS.postMessage("contractEncodeCall");
                client.getContractInstance(sourceCodeSwap, {contractAddress: swapCtId}).then(tokenContract => {
                    tokenContract.methods.get_swaps_icon(coinName).then((swapsIcon) => {
                        let coinsArray = [];
                        for (let i = 0; i < swapsIcon.decodedResult["account_map"].length; i++) {
                            let coin = new Map();
                            coin["account"] = swapsIcon.decodedResult["account_map"][i][1]["account"];
                            coin["ae"] = Ae.AmountFormatter.toAe(swapsIcon.decodedResult["account_map"][i][1]["ae"]);
                            coin["coin"] = swapsIcon.decodedResult["account_map"][i][1]["coin"];
                            coin["count"] = Ae.AmountFormatter.toAe(swapsIcon.decodedResult["account_map"][i][1]["count"]);
                            coinsArray.push(coin);
                        }
						status_JS.postMessage("sucess");
						contractSwapGetSwapsIcon_JS.postMessage(JSON.stringify(coinsArray));
                    }).catch(err => {
                        status_JS.postMessage("error");
                        error_JS.postMessage(err.toString());
                    });
                }).catch(err => {
                    status_JS.postMessage("error");
                    error_JS.postMessage(err.toString());
                });
            }).catch(err => {
                status_JS.postMessage("error");
                error_JS.postMessage(err.toString());
            })
        }).catch(err => {
            status_JS.postMessage("error");
            error_JS.postMessage(err.toString());
        });
    };

    const contractSwapGetAccountsAddress = function (secretKey, publicKey, swapCtId , address) {
        Ae.Node({url: nodeUrl, internalUrl: nodeUrlTestNet}).then(node => {
            Ae.Universal({
                compilerUrl: compilerUrl,
                nodes: [{name: 'local', instance: node}],
                accounts: [Ae.MemoryAccount({
                    keypair: {
                        secretKey: secretKey,
                        publicKey: publicKey
                    }
                }),],
                address: publicKey,
            }).then(client => {
                status_JS.postMessage("contractEncodeCall");
                client.getContractInstance(sourceCodeSwap, {contractAddress: swapCtId}).then(tokenContract => {
                    tokenContract.methods.get_accounts_address(address).then((accounts) => {
                        let coinsArray = [];
                        for (let i = 0; i < accounts.decodedResult["coin_map"].length; i++) {
                            let coin = new Map();
                            coin["account"] = accounts.decodedResult["coin_map"][i][1]["account"];
                            coin["ae"] = Ae.AmountFormatter.toAe(accounts.decodedResult["coin_map"][i][1]["ae"]);
                            coin["coin"] = accounts.decodedResult["coin_map"][i][1]["coin"];
                            coin["count"] = Ae.AmountFormatter.toAe(accounts.decodedResult["coin_map"][i][1]["count"]);
                            coinsArray.push(coin);
                        }
						status_JS.postMessage("sucess");
                        contractSwapGetAccountsAddress_JS.postMessage(JSON.stringify(coinsArray));
                    }).catch(err => {
						status_JS.postMessage("error");
						error_JS.postMessage(err.toString());
                    });
                }).catch(err => {
                    status_JS.postMessage("error");
                    error_JS.postMessage(err.toString());
                });
            }).catch(err => {
                status_JS.postMessage("error");
                error_JS.postMessage(err.toString());
            })
        }).catch(err => {
            status_JS.postMessage("error");
            error_JS.postMessage(err.toString());
        });
    };














    const contractDefiV2Lock = function (secretKey, publicKey, ctId, amount) {
        Ae.Node({url: nodeUrl}).then(node => {
            Ae.Universal({
                compilerUrl: compilerUrl,
                nodes: [{name: 'local', instance: node}],
                accounts: [Ae.MemoryAccount({
                    keypair: {
                        secretKey: secretKey,
                        publicKey: publicKey
                    }
                }),],
                address: publicKey,
            }).then(client => {
                status_JS.postMessage("contractEncodeCall");
                client.contractEncodeCall(sourceCodeDefiV2, 'lock', []).then(callDataCall => {
                    status_JS.postMessage("contractCall");
                    client.contractCall(sourceCodeDefiV2, ctId, "lock", callDataCall, {amount: Ae.AmountFormatter.toAettos(amount)}).then(callResult => {
                        status_JS.postMessage("decode");
                        callResult.decode().then(callResultDecode => {
                            status_JS.postMessage("sucess");
                            contractDefiV2Lock_JS.postMessage(callResultDecode);

                        }).catch(err => {
                            status_JS.postMessage("error");
                            error_JS.postMessage(err.toString());
                        })
                    }).catch(err => {

                        status_JS.postMessage("error");
                        if(err.toString().indexOf("Decoded") !== -1 ){
                            var decode = err.toString().split('Decoded: ')
                            var msg = decode[1].substring(1, decode[1].length - 4)
                            error_JS.postMessage(msg);
                        }else{
                            error_JS.postMessage(err.toString());
                        }


                    })
                }).catch(err => {
                    status_JS.postMessage("error");
                    error_JS.postMessage(err.toString());
                })
            }).catch(err => {
                status_JS.postMessage("error");
                error_JS.postMessage(err.toString());
            })
        }).catch(err => {
            status_JS.postMessage("error");
            error_JS.postMessage(err.toString());
        });
    };

    const contractDefiV2UnLock = function (secretKey, publicKey, ctId, amount) {
        Ae.Node({url: nodeUrl}).then(node => {
            Ae.Universal({
                compilerUrl: compilerUrl,
                nodes: [{name: 'local', instance: node}],
                accounts: [Ae.MemoryAccount({
                    keypair: {
                        secretKey: secretKey,
                        publicKey: publicKey
                    }
                }),],
                address: publicKey,
            }).then(client => {
                status_JS.postMessage("contractEncodeCall");
                client.contractEncodeCall(sourceCodeDefiV2, 'unLock', [Ae.AmountFormatter.toAettos(amount)]).then(callDataCall => {
                    status_JS.postMessage("contractCall");
                    client.contractCall(sourceCodeDefiV2, ctId, "unLock", callDataCall, {}).then(callResult => {
                        status_JS.postMessage("decode");
                        callResult.decode().then(callResultDecode => {
                            status_JS.postMessage("sucess");
                            contractDefiV2UnLock_JS.postMessage(callResultDecode);
                        }).catch(err => {
                            status_JS.postMessage("error");
                            error_JS.postMessage(err.toString());
                        })
                    }).catch(err => {
                        status_JS.postMessage("error");
                        if(err.toString().indexOf("Decoded") !== -1 ){
                            var decode = err.toString().split('Decoded: ')
                            var msg = decode[1].substring(1, decode[1].length - 4)
                            error_JS.postMessage(msg);
                        }else{
                            error_JS.postMessage(err.toString());
                        }


                    })
                }).catch(err => {
                    status_JS.postMessage("error");
                    error_JS.postMessage(err.toString());
                })
            }).catch(err => {
                status_JS.postMessage("error");
                error_JS.postMessage(err.toString());
            })
        }).catch(err => {
            status_JS.postMessage("error");
            error_JS.postMessage(err.toString());
        });
    };
    const contractDefiV2Benefits = function (secretKey, publicKey, ctId) {
        Ae.Node({url: nodeUrl}).then(node => {
            Ae.Universal({
                compilerUrl: compilerUrl,
                nodes: [{name: 'local', instance: node}],
                accounts: [Ae.MemoryAccount({
                    keypair: {
                        secretKey: secretKey,
                        publicKey: publicKey
                    }
                }),],
                address: publicKey,
            }).then(client => {
                status_JS.postMessage("contractEncodeCall");
                client.contractEncodeCall(sourceCodeDefiV2, 'benefits', []).then(callDataCall => {
                    status_JS.postMessage("contractCall");
                    client.contractCall(sourceCodeDefiV2, ctId, "benefits", callDataCall, {}).then(callResult => {
                        status_JS.postMessage("decode");
                        callResult.decode().then(callResultDecode => {
                            status_JS.postMessage("sucess");
                            contractDefiV2Benefits_JS.postMessage(callResultDecode);
                        }).catch(err => {
                            status_JS.postMessage("error");
                            error_JS.postMessage(err.toString());
                        })
                    }).catch(err => {
                        status_JS.postMessage("error");
                        if(err.toString().indexOf("Decoded") !== -1 ){
                            var decode = err.toString().split('Decoded: ')
                            var msg = decode[1].substring(1, decode[1].length - 4)
                            error_JS.postMessage(msg);
                        }else{
                            error_JS.postMessage(err.toString());
                        }


                    })
                }).catch(err => {
                    status_JS.postMessage("error");
                    error_JS.postMessage(err.toString());
                })
            }).catch(err => {
                status_JS.postMessage("error");
                error_JS.postMessage(err.toString());
            })
        }).catch(err => {
            status_JS.postMessage("error");
            error_JS.postMessage(err.toString());
        });
    };


    const contractTransfer = function (secretKey, publicKey, ctId, receiveID, amount,type) {
        Ae.Node({url: nodeUrl}).then(node => {
            Ae.Universal({
                compilerUrl: compilerUrl,
                nodes: [{name: 'local', instance: node}],
                accounts: [Ae.MemoryAccount({
                    keypair: {
                        secretKey: secretKey,
                        publicKey: publicKey
                    }
                }),],
                address: publicKey,
            }).then(client => {
                status_JS.postMessage("contractEncodeCall");
                var source = sourceCodeABC;
                 if(type == "ABC"){
                     source = sourceCodeABC;
                 }else if(type == "basic"){
                     source = sourceCodeTokenBasic;
                 }else {
                     source = sourceCodeToken;
                 }
                client.contractEncodeCall(source, 'transfer', [receiveID, Ae.AmountFormatter.toAettos(amount)]).then(callDataCall => {
                    status_JS.postMessage("contractCall");
                    client.contractCall(source, ctId, "transfer", callDataCall).then(callResult => {
                        status_JS.postMessage("decode");
                        callResult.decode().then(callResultDecode => {
                            status_JS.postMessage("sucess");
                            contractTransfer_JS.postMessage(callResultDecode);

                        }).catch(err => {
                            status_JS.postMessage("error");
                            error_JS.postMessage(err.toString());
                        })
                    }).catch(err => {
                        status_JS.postMessage("error");
                        if(err.toString().indexOf("Decoded") !== -1 ){
                            var decode = err.toString().split('Decoded: ')
                            var msg = decode[1].substring(1, decode[1].length - 4)
                            error_JS.postMessage(msg);
                        }else{
                            error_JS.postMessage(err.toString());
                        }


                    })
                }).catch(err => {
                    status_JS.postMessage("error");
                    error_JS.postMessage(err.toString());
                })
            }).catch(err => {
                status_JS.postMessage("error");
                error_JS.postMessage(err.toString());
            })
        }).catch(err => {
            status_JS.postMessage("error");
            error_JS.postMessage(err.toString());
        });
    };

    const contractDefiUnLockV1 = function (secretKey, publicKey, ctId, height) {
        Ae.Node({url: nodeUrl}).then(node => {
            Ae.Universal({
                compilerUrl: compilerUrl,
                nodes: [{name: 'local', instance: node}],
                accounts: [Ae.MemoryAccount({
                    keypair: {
                        secretKey: secretKey,
                        publicKey: publicKey
                    }
                }),],
                address: publicKey,
            }).then(client => {
                status_JS.postMessage("contractEncodeCall");
                var source;
                if (ctId == 'ct_Evidt2ZUPzYYPWhestzpGsJ8uWzB1NgMpEvHHin7GCfgWLpjv') {
                    source = sourceCodeDefiV1;
                } else {
                    source = sourceCodeDefiV1Fix;
                }

                client.contractEncodeCall(source, 'unlock', [height]).then(callDataCall => {
                    status_JS.postMessage("contractCall");
                    client.contractCall(source, ctId, "unlock", callDataCall).then(callResult => {
                        status_JS.postMessage("decode");
                        callResult.decode().then(callResultDecode => {
                            status_JS.postMessage("sucess");
                            contractDefiUnLockV1_JS.postMessage(callResultDecode);

                        }).catch(err => {
                            status_JS.postMessage("error");
                            error_JS.postMessage(err.toString());
                        })
                    }).catch(err => {
                        status_JS.postMessage("error");
                        if(err.toString().indexOf("Decoded") !== -1 ){
                            var decode = err.toString().split('Decoded: ')
                            var msg = decode[1].substring(1, decode[1].length - 4)
                            error_JS.postMessage(msg);
                        }else{
                            error_JS.postMessage(err.toString());
                        }


                    })
                }).catch(err => {
                    status_JS.postMessage("error");
                    error_JS.postMessage(err.toString());
                })
            }).catch(err => {
                status_JS.postMessage("error");
                error_JS.postMessage(err.toString());
            })
        }).catch(err => {
            status_JS.postMessage("error");
            error_JS.postMessage(err.toString());
        });
    };

    const spend = function (secretKey, publicKey, receiveID, amount) {
        Ae.Node({url: nodeUrl}).then(node => {
            Ae.Universal({
                nodes: [{name: 'local', instance: node}],
                accounts: [Ae.MemoryAccount({
                    keypair: {
                        secretKey: secretKey,
                        publicKey: publicKey
                    }
                }),],
                address: publicKey,
            }).then(client => {
                status_JS.postMessage("broadcast");
                client.spend(
                    Ae.AmountFormatter.toAettos(amount),
                    receiveID,
                    {
                        payload: 'Box aepp',
                        waitMined: false
                    },
                ).then(res => {
                    const {blockHeight, hash, tx} = res;
                    status_JS.postMessage("sucess");
                    spend_JS.postMessage(hash);

                }).catch(err => {
                    status_JS.postMessage("error");
                    error_JS.postMessage(err.toString());
                })
            }).catch(err => {
                status_JS.postMessage("error");
                error_JS.postMessage(err.toString());
            })
        }).catch(err => {
            status_JS.postMessage("error");
            error_JS.postMessage(err.toString());
        })
    };


    const claimName = function (signingKey, publicKey, name) {
        Ae.Node({url: nodeUrl}).then(node => {
            Ae.Universal({
                nodes: [{name: 'local', instance: node}],
                accounts: [
                    Ae.MemoryAccount({
                        keypair: {
                            secretKey: signingKey,
                            publicKey: publicKey
                        }
                    }),
                ],
                address: publicKey,
            }).then(aeInstance => {
                status_JS.postMessage("aensPreclaim");
                aeInstance.aensPreclaim(name).then(function (preclaim) {
                    status_JS.postMessage("aensClaim");
                    aeInstance.aensClaim(name, preclaim.salt, {waitMined: false}).then(function (claim) {
                        status_JS.postMessage("sucess");
                        claimName_JS.postMessage(claim.hash);
                    }).catch(function (err) {
                        status_JS.postMessage("error");
                        error_JS.postMessage(err.toString());
                    });
                }).catch(function (err) {
                    status_JS.postMessage("error");
                    error_JS.postMessage(err.toString());
                })
            }).catch(err => {
                status_JS.postMessage("error");
                error_JS.postMessage(err.toString());
            });
        }).catch(err => {
            status_JS.postMessage("error");
            error_JS.postMessage(err.toString());
        });
    }

    const updateName = function (signingKey, publicKey, name) {
        Ae.Node({url: nodeUrl}).then(node => {
            Ae.Universal({
                nodes: [{name: 'local', instance: node}],
                accounts: [
                    Ae.MemoryAccount({
                        keypair: {
                            secretKey: signingKey,
                            publicKey: publicKey
                        }
                    }),
                ],
                address: publicKey,
            }).then(aeInstance => {
                const pointersArray = [publicKey];
                status_JS.postMessage("aensUpdate");
                aeInstance.aensUpdate(name, pointersArray, {
                    extendPointers: true,
                    waitMined: false
                }).then(function (update) {
                    status_JS.postMessage("sucess");
                    updateName_JS.postMessage(update.hash);
                }).catch(function (err) {
                    status_JS.postMessage("error");
                    error_JS.postMessage(err.toString());
                })
            }).catch(function (err) {
                status_JS.postMessage("error");
                error_JS.postMessage(err.toString());
            })
        }).catch(function (err) {
            status_JS.postMessage("error");
            error_JS.postMessage(err.toString());
        });
    }


    const bidName = function (signingKey, publicKey, name, nameFee) {
        Ae.Node({url: nodeUrl}).then(node => {
            Ae.Universal({
                nodes: [{name: 'local', instance: node}],
                accounts: [
                    Ae.MemoryAccount({
                        keypair: {
                            secretKey: signingKey,
                            publicKey: publicKey
                        }
                    }),
                ],
                address: publicKey,
            }).then(aeInstance => {
                status_JS.postMessage("aensPreclaim");
                aeInstance.aensPreclaim(name).then(function (preclaim) {
                    status_JS.postMessage("aensBid");
                    aeInstance.aensBid(name, Ae.AmountFormatter.toAettos(nameFee), {waitMined: false}).then(function (bid) {
                        console.log("AE bid hash:" + bid.hash);
                        status_JS.postMessage("sucess");
                        bidName_JS.postMessage(bid.hash);
                    }).catch(function (err) {
                        status_JS.postMessage("error");
                        error_JS.postMessage(err.toString());
                    });
                }).catch(function (err) {
                    status_JS.postMessage("error");
                    error_JS.postMessage(err.toString());
                })
            }).catch(function (err) {
                status_JS.postMessage("error");
                error_JS.postMessage(err.toString());
            })
        }).catch(function (err) {
            status_JS.postMessage("error");
            error_JS.postMessage(err.toString());
        });
    }

    const getMnemonic = function () {
        const mnemonic = Ae.HdWallet.generateMnemonic();
        const publicKeyInsecretKey = Ae.HdWallet.getHdWalletAccountFromMnemonic(mnemonic, 0);
        const publicKey = publicKeyInsecretKey.publicKey;
        const secretKey = publicKeyInsecretKey.secretKey;
        getMnemonic_JS.postMessage(publicKey + "#" + secretKey + "#" + mnemonic);
    };

    const getSecretKey = function (mnemonic) {
        const publicKeyInsecretKey = Ae.HdWallet.getHdWalletAccountFromMnemonic(mnemonic, 0);
        const publicKey = publicKeyInsecretKey.publicKey;
        const secretKey = publicKeyInsecretKey.secretKey;
        getSecretKey_JS.postMessage(publicKey + "#" + secretKey);
    };


    var validationMnemonic = function (mnemonic) {
        try {
            Ae.HdWallet.generateSaveHDWallet(mnemonic, 0);
            validationMnemonic_JS.postMessage("sucess");
            return true;
        } catch (err) {
            validationMnemonic_JS.postMessage("error");
            return err.message
        }
    }


</script>
</body>


</html>
